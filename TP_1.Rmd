---
title: "Première manipulation avec R"
author: "PC"
date: "2021"
output: 
   html_document :
     theme: paper
     toc_float: 
        collapsed: false
     toc: yes
     highlight: tango
     number_sections: yes
     number_subsections: yes
self-contained : yes
---





  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(class.source = "bg.success")
library(rmarkdown)
library(dplyr)
```


```{css, echo=FALSE}
.code_guide {
  background-color: #FF0000;
}
```


# Hello World

La fonction `print` affiche une chaîne de caractère ou une valeur numérique passé en argument 

```{r hw}
print("Hello World!")
```

La fonction `cat` permet d'afficher plusieurs éléments , séparés par des virgules

```{r cat}
cat("Hello", "World", "!")
```

`cat` accepte des éléments de type différent. Ici , une chaîne de caractère, un nombre, le résultat d'une fonction et un booléen  :

```{r catmix}
cat("abc", 12.3, sqrt(49), TRUE)
```



# Installer et charger des librairies

L'installation et le chargement des packages  au moyen des fonctions `install.packages("nom_du_package")` et `library(nom_du_package)`

Ci-dessous un exemple avec le package `dplyr` qui permet d'enchaîner des traitements comme nous le verrons plus loin, et le package `palmerpenguins` qui contient des mesures sur des pingouins.



```{r setuplib1, eval=FALSE,cache =TRUE}
install.packages("dplyr")
library(dplyr)
```


Le package `dplyr` est très utile, reportez vous à la cheat-sheet (ici en français) [https://thinkr.fr/pdf/dplyr-french-cheatsheet.pdf] pour en avoir un résumé des fonctions.


```{r setuplib2, cache =TRUE}
install.packages("plamerpenguins")
library(palmerpenguins)
# aperçu des premières lignes du dataset
head(penguins)
```






# Déclarer une variable 

Une variable se déclare avec l'opérateur `<-` (recommandé) ou `=`  .
Écrire le nom de la variable sur une ligne puis l'éxécuter renvoie la valeur courante de la variable.
Si la ligne contient une opération ou l'appel d'une fonction, le résultat est affiché dans la console. 

```{r decl}
a <-  5
a
a + 10
```


## Types primitifs 

Les types primitifs en R sont : `numeric` , `character` (string) , `logical` (booléen), et `factor`

Voici des exemples d'instantiation:

```{r decl2}
nunu <-  12.5
chacha <-  "Lorem Ipsum"
lolo <-  FALSE
fafa <-  factor(c("riri", "fifi", "loulou"))
```



# Vecteur 


La fonction `vector` permet d'initialiser un vecteur d'une certaine longueur et d'un certain type atomique (`numeric`, `logical` , ou `character`)

```{r vec}
veve <- vector(mode="numeric", length= 10 )
veve
```

Les opérations classiques appliquées à un vecteur sont «vectorisées», c'est-à-dire qu'elles sont appliquées terme à terme au vecteur .
```{r vec2}
veve + 15 
```


On peut également utiliser la fonction `c()` pour créer des collections en combinant des objets. Lorsqu'ils sont de type identique cela produit un vecteur 


```{r vec3}
coco <-  c(10,20,30,40,50,60,70,80,90)
coco
```


## Modifier un élément

Connaissant son index (= sa position dans le vecteur),  la modification de la valeur d'un élément  se fait à l'aide de l'opérateur d'affectation : 


```{r vecmodif}
coco
coco[5] <-  10000
coco
```


## Ajouter une élément


On peut ajouter un élément à la fin d'un vecteur avec la fonction `c()` qui combine une valeur avec un objet et renvoie un élément de même type  que l'objet combiné (ici : un vecteur)


```{r vecajout}
c(coco, "3.1416")
```



## Supprimer un élément


Supprimer un élément d'un vecteur se fait d'un façon particulière : en excluant l'élément avec un signe "moins" devant son index.

```{r vecsupp}
coco
coco[-5] 
# pour supprimer effectivement le cinquième élément , il faut mettre à jour la variable avec une affectation 
coco <- coco[-5]
```


# Liste 

On utilise la fonction `list()`  pour initialiser une liste : 

```{r lili}
lili <-  list(1,2,3) 
lili
```


La fonction `list()` accepte des éléments de type différents : 

```{r lili2}
lili2 <- list("abc", 15==3*5, 12.3)
lili2
```

Dans cet exemple , le troisième terme utilise l'opérateur d'égalité, `==` qui teste si les deux opérandes sont égaux. 


Une liste peut être nommée , c'est à dire stocker un nom pour chaque élément qu'elle contient, avec la fonction `names()` qui, suivant son utilisation, renvoie ou affecte des noms aux éléments d'une liste 


```{r lili3}
# affection des noms 
names(lili2) <- c("premier élement", "deuxième élément", "troisième élément")
#affichage standard de la liste en console
lili2
#affichage des  noms
```




## Ajouter des éléments 

On peut ajouter un élément à la fin d'une liste avec la fonction `c()` qui combine une valeur avec un objet et renvoie un élément de même type  que l'objet (liste ou vecteur).

```{r addelem}
c(lili,4)
```

## Supprimer un élément


Comme pour un vecteur, affecter la valeur `NULL` à un élément de la liste a pour effet de le supprimer. Supprimer un élément d'une liste a pour effet de réduire la taille de cette liste d'une unité et de "recoller les morceaux , comme le montre la séquence suivante : 

```{r removeelem}
lili <- list(1,2,3,4,5)
lili[[3]] <-  NULL
lili
```

Notez l'emploi des doubles crochets pour accéder à un élément de la liste, à la différence du crochet simple pour les vecteurs.



# Exercice \#1   

1. Créer une liste de 3 éléments 
2. Changer la valeur du deuxième élément de votre objet
3. Affecter à l'objet les trois noms suivants : "A" , "B" et "C"
4. Ajouter un élément à votre objet 
5. Nommer cet élément ajouté
6. Supprimer le troisième élément de cette liste
7. Afficher l'objet final et sa longueur


# Dataframes

Le type d'objet le plus courant dans R est le **dataframe** :  un tableau de données dont les colonnes ont des noms et peuvent être de différents types. 
Par convention, le format des données est de mettre en ligne les valeurs d'un individus, et en colonnes les variables qui le décrivent.


R propose un jeu de données appelé `iris` décrivant les caractéristiques de fleurs de différentes espèces d'iris , ici on présente les 6 premières lignes avec la fonction `head`: 

```{r iris}
head(iris)
```

les noms des colonnes d'un dataframe sont obtenus avec la fonction `names()`

```{r irisnames}
names(iris)
```



## Accès aux valeurs


un dataframe est un tableau à deux dimensions, on peut donc accéder à la valeur d'un élément avec deux indices placés entre crochets et séparé par une virgule : celui de la ligne voulue puis celui de la colonne voulue

```{r irisacces}
iris[12, 4]
```

On peut également utiliser le nom d'une colonne pour indiquer la colonne désirée :


```{r irisacces2}
iris[12, "Petal.Width"]
```


### Toutes les lignes, toutes les colonnes

Si on ne précise pas les indices, R sélectionne toutes les valeurs

Pour accéder à toutes les lignes d'une colonne, on écrit donc 

```{r irisacces3}
iris[, "Petal.Width"]
```

Pour accéder à toutes les colonnes d'une ligne, on écrit donc 

```{r irisacce4}
iris[12, ]
```


### Exclure des lignes ou des colonnes


Pour exclure une ligne ou une colonne on procède comme pour l'accès, mais en utilisant le signe "moins" devant les **indices**  lignes ou les colonnes à exclure : 

```{r irismoins}
iris[, -c(3,4)]
```

Pour exclure des lignes , on procède de même. 
Dans l'exemple ci-dessous, j'utilise l'opérateur `:` qui produit une séquence d'entiers entre les deux nombres qui l'entourent : 


```{r irismoins2}
iris[ -(10:150), ]
```

Comme le dataframe `iris` contient 150 lignes (pour le calculer , utiliser la fonction `nrow()`), on obtient donc les 9 premières lignes du dataframe.


## L'opérateur `$`  


Il est courant de vouloir opérer des transformations aux colonnes d'un dataframe. Pour cela, on peut utiliser l'opérateur `$` sur les objets de type dataframe :


```{r irisdollar}
iris$Species
```


Par exemple, pour calculer la valeur moyenne d'une colonne numérique du dataframe `iris`, on utilise fonction `mean()` directement sur la colonne voulue : 

```{r irismean}
mean(iris$Sepal.Width)
```


N.B. : les noms de colonnes d'un dataframe chargé en mémoire sont proposés à la complétion après le symbole dollar dans la console ou dans l'éditeur de Rstudio, ce qui est très pratique.


## Accès conditionnels 

Lors de l'accès à des éléments d'un dataframe, on peut faire une condition booléenne pour ne sélectionner que les éléments qui remplissent cette condition. 
Cette condition booléenne s'écrit dans **l'indexation par ligne** , i.e. à **gauche** de la virgule entre les crochets 

Voici comment ne sélectionner que les individus du dataframe `iris` dont la variable `Species` vaut `virginica`.



```{r iriscondition}
iris[iris$Species=="virginica",]
```


## Filtrages

Pour filtrer un dataset selon plusieurs critères , il peut être utile d'utiliser la fonction `which`

```{r whichfilter}
iris[which(iris$Species=="setosa" & iris$Sepal.Length > 5.5),]
```


## Modifier une valeur

Modifier une valeur se fait par affectation, à la ligne et à la colonne voulue. 
Attention à bien respecter les types ! 


Dans l'exemple ci dessous, on utilise une copie pour modifier les valeurs sans  concéquences sur le dataset original 

```{r modif}
irisclone <-  iris
irisclone[ 10 , "Sepal.Length"] <-  "12345.67"
irisclone[ 10 , "Sepal.Length"]
```



## Supprimer une valeur


Devoir supprimer une valeur est assez rare, les données étant bien plus souvent filtrées que détruites.
Néanmoins , on peut supprimer une valeur en lui affectant la valeur `NA` ou `NULL` (déconseillé)


## Ajouter de nouvelles valeurs (des lignes et des colonnes)

On ne peut pas ajouter une seule valeur dans un dataframe, il faut ajouter des lignes ou des colonnes

On utilise les fonctions `rbind` et `cbind` pour joindre respectivement des rows (lignes) ou des cols (colonnes)


```{r addcol}
irisclone$nouvelleColonne <-  seq(from=48, by= 5, length.out=nrow(irisclone) )
```

Pour l'ajout de lignes, il faut respecter l'**ordre** et le **type** des colonnes existantes .
En particulier pour les facteurs, il faut ajouter une valeur qui appartienne aux modalités des facteurs , sans quoi  la valeur est remplacée par NA , ce qui produit un warning :

```{r addrow}
nouvelleLigne <-  c(24, 45, 111, -54, "pouet", 123)
irisclone <-  rbind(irisclone, nouvelleLigne)
```


##  Opérations sur des collections de valeurs 

la plupart des opérations arithmétiques sont appliquées terme à terme aux éléments des collections : listes, vecteurs, et colonnes de dataframe

```{r ope }
iris$Petal.Length * 100
```


D'autre fonctions courantes sont disponibles : 

### Moyenne , médiane , écart type

```{r foncfonc}
mean(iris$Sepal.Width)
median(iris$Petal.Length)
sd(iris$Petal.Width)
```

### Somme ,Produit et somme cumulée

```{r foncfonc2}
sum(iris$Sepal.Width)
prod(iris$Petal.Length)
cumsum(iris$Petal.Width)
```


## Affichage simple 


Quand on veut visualiser un nuage de points, on peut utiliser la fonction `plot` , soit sur deux vecteurs, soit sur tout un dataframe. 
N.B. : Dans le cas d'un plot sur un dataframe , les facteurs sont transformés en nombres entiers


```{r ploplo}
plot(iris)
```

avec deux vecteurs, on écrit le nom des vecteur séparés par des virgules 

```{r ploplo2}
vect1 <-  c(1,2,3,4,5,6,7,8,9,10)
vect2 <-  c(1,1,3,3,5,5,8,8,9,9)
plot(vect1,vect2)
```


Le package `ggplot2` permet de réaliser des graphiques plus complexes et mieux rendus. Je vous encourage chaudement à en apprendre les grands principes par vous même. 


```{r ggplot}
library(ggplot2)
joli_plot <-  ggplot(iris)+
  geom_point( aes(x= Sepal.Length, y = Petal.Width, color=Species))
joli_plot

```




## Combinaison de facteurs et tableaux de contingence


Lorqsqu'on dispose d'un jeu de données avec deux variable qualitatives, il est intéressant de combiner les deux variables et de réaliser un tableau de contingence , c'est à dire , compter les occurences (i.e. l'effectif) par combinaison de valeurs des modalités 


ON utilise pour cela les fonction `table` .


Voici un exemple avec le jeu de données du package `palmerpenguins`


```{r tab}
library(palmerpenguins)
tab_conting <- table(penguins$species, penguins$island)
tab_conting
```

La fonction `prop .table` transforme un tableau de contingence en tableau de pourcentages : 

```{r tabpct}
prop.table(tab_conting)
```



## Définir sa propre fonction 

  
Une fonction  se définit avec un nom, une affectation et le mot clé `function` . Les paramètres sont entre parenthèses, et le code de la fonction dans des accolades. 

Le mot clé `return`  est utilisé pour retourner le résultat de la fonction.
  
  
```{r userfunc}
my_func <-  function(p1, p2){
  return( p1*100 + p2)
}
my_func(4,6)
x <-  my_func(1,1)
x
```

Pour être appelée, le code d'une fonction doit être exécuté une fois au préalable. Vous verrez ensuite la fonction apparaître dans votre environnement.



# Lecture et Écriture de fichier CSV


Pour lire un fichier au format CSV, on utilise la fonction `read.csv`. Consultez la documentation pour plus de détails , notamment concernant les séparateurs(argument `sep`). 

```{r reading}
pokedex <-  read.csv("./pokemons.csv", sep=",")
head(pokedex)
```



### Strings as factor


Par défaut , R considère que les variables chaînes de caractères sont des facteurs ce qui peut compliquer certains traitements. 
Il est fortement conseillée de désactiver cette option, en ajoutant l'argument `stringsAsFactors = FALSE` aux fonctions de lectures de fichiers tabulaires.


# Exercice complet 

- Récupérer le fichier `pokemons.csv` sur le répertoire partagée de la formation. 

- Lire le fichier et le charger dans un dataframe  

- Créer un second dataframe avec une sélection de deux types de pokemons (au choix)

- Calculer la moyenne et la médiane des points d'attaque et de défense de ces deux types de pokemons 

- En vous inspirant d'un des deux codes ci-dessous , produisez un graphique qui affiche le niveau d'attaque en fonction du niveau de défense des pokemons sélectionnés, en distinguant les types de pokemons par la couleur.


Ce bout de code charge un dataset sur des pingouins : l'objet `penguins`, puis affiche deux variables sous la forme d'un nuage de points colorés selon une troisième variable : 

```{r expleplotiris}
library(palmerpenguins)
plot(x=penguins$flipper_length_mm, y=penguins$body_mass_g, 
     col=iris$Species, 
     main = "Longueur des nageoires et masse des pingouins",
     xlab="Longueur des nageoires (mm) ",
     ylab="Masse (g)")
```

Une version utilisant le package `ggplot2`



```{r expleplotirisggplot}
library(palmerpenguins)
library(ggplot2)

 graph1 <-  ggplot(penguins)+
   geom_point(aes(x=flipper_length_mm, y=body_mass_g, color=species))+
   ggtitle("Longueur des nageoires et masse des pingouins")+
   xlab("Longueur des nageoires (mm)" )+
   ylab("Masse (g)")
graph1
```











